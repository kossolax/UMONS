\documentclass[hidelinks,a4paper, 12pt]{article}
\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}
\usepackage{svg}
\usepackage{cleveref}
\usepackage{subfig}
\usepackage{gensymb}
\usepackage{slashbox}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
\makeatletter
\pgfplotsset{
	/tikz/min node/.style={
		anchor=north
	},
	mark min/.style={
		point meta rel=per plot,
		visualization depends on={x \as \xvalue},
		scatter/@pre marker code/.code={
			\ifx\pgfplotspointmeta\pgfplots@metamin
			\def\markopts{}
			\else
			\def\markopts{mark=none}
			\fi
			\expandafter\scope\expandafter[\markopts,every node near coord/.style=green]
		},
		scatter/@post marker code/.code={
			\endscope
		},
		scatter,
	},
}
\usepackage[titletoc,title]{appendix}
\lstset{language=C,rangeprefix=//---------------,rangesuffix=----------------,includerangemarker=false,columns=spaceflexible,extendedchars=true,showspaces=false,showstringspaces=false,inputencoding=ansinew,tabsize=4,frame=shadowbox,morecomment=[is]{\#ifdef}{\#endif},morecomment=[is]{/*}{*/}}
\title{Lecture et rédaction scientifiques: \\Skip-lists }
\author{Steve Zaretti}

\begin{document}
	
	\maketitle
	\newpage
	\tableofcontents
	\newpage
	
	\section{Introduction}
	En informatique, il est courant de vouloir enregistrer des données quelconques. Une structure de données est une représentation logique de ces données. La manière de représenter les données permet de résoudre différents problèmes. Une structure précise peut être plus performante pour un cas précis ou, au contraire, être très peu performante. D’autre part, une meilleur organisation de l'information peut aussi réduire de façon significative la complexité d’un algorithme.
	
	Il existe un grand nombre de structures de données, toutes proposent aux concepteurs de logiciel deux fonctionnalités standards : enregistrer et récupérer un renseignement. Selon l’approche employée pour la représentation logique, les performances seront différentes. Certaines structures de données offrent la possibilité de récupérer le premier élément en temps constant, au détriment du temps d’accès aux autres éléments. Alors que d’autres permettent un accès en temps constant à chacun des éléments en dépit d’une durée plus longue pour l’enregistrement d'une information.
	
	\subsection{Liste chainée}
	Une liste chainée \cref{LinkedList} est une structure de données de taille variable. Le principe est que chacun des éléments de cette liste contient une référence vers l'élément suivant. Cette pratique facilite l'insertion et la suppression des éléments, au détriment de la rapidité de la recherche.
	
	Une liste chainée peut aussi être triée, ce qui inverse les conséquences sur ses performances. Une insertion devient plus compliquée, car il faut rechercher, avant tout, ou placer l'élément dans la liste afin de garder la structure cohérente.
	
	La recherche dans une liste chainée s'effectue élément par élément: si ce n'est pas le premier élément de la liste, il faut regarder le second. Si ce n'est pas celui-ci, il faut alors regarder celui d'après jusqu'à ce que l'élément recherché soit trouvé ou qu'il n'y ait pas d'élément suivant. Dans le cas d'une liste chainée croissante, la recherche peut s'arrêter plus tôt: si l'élément que l'on regarde est plus grand que celui qui est recherché.
	
	\begin{figure}[h]
		\includegraphics[width=\textwidth]{img/linkedList}
		\caption{Liste chainée ordonnées}
		\label{LinkedList}
	\end{figure}
	
	\subsubsection*{Les alternatives}
	Il existe de nombreuses alternatives aux listes chainées pour trouver un élément plus rapidement: les tables de hashage \cref{hashing}, les arbres binaires \cref{tree}, etc. Mais certaines séquences d'insertions peuvent être catastrophiques. Par exemple, insérer des éléments croissants dans un arbre binaire provoque un rééquilibrage de l'arbre. En revanche, si les éléments sont insérés de façon aléatoire, l'équilibrage devient plus rare.

	Grâce aux probabilités, les \og skip-list \fg{} \cref{skip} bénéficient d'un atout majeur: aucune séquence ne peut provoquer systématiquement le pire scénario. Mieux encore, les skip-lists utilisent des algorithmes plus simples que ses concurrents.
	
	\begin{figure}[h]
		\centering
		\subfloat[Table de hashage] {
			\includegraphics[scale=0.75]{img/hashing}
			\label{hashing}
		}
		\subfloat[Arbre binaire] {
			\includegraphics[scale=0.75]{img/tree}
			\label{tree}
		}
		\caption{Différentes structures de données}
	\end{figure}
	\begin{figure}
		\includegraphics[width=\textwidth]{img/skip}
		\caption{Skip-list}
		\label{skip}
	\end{figure}
	
	\newpage
	\subsection{Skip-List}
	
	
	Tout comme un dictionnaire, une skip-list permet de récupérer la définition d'un terme recherché \textit{(dit clé)}. Cette recherche est rapide, car les éléments \textit{(dit nœud)} présents dans un dictionnaire sont triés et il est possible de commencer une exploration plus approfondie à un endroit précis.
	Une skip-list bénéficie des avantages de la liste chainée, en limitant fortement ses inconvénients. Cette structure de données utilise les chaines de façon parallèle. Une fonction basée sur des probabilités permet de déterminer la hauteur de la chaine. Plus cette hauteur est élevée, moins la liste contient d'éléments. Une couche haute est donc un accès plus rapide vers des éléments plus loin dans la liste.
	
	
	
	Afin d'illustrer la skip-liste, il faut l'imaginer comme un réseau de transport en commun idéal où le temps d'attente des correspondances est nul. Un nœud dans la skip-liste est un arrêt obligatoire dans lequel un passager peut changer de moyen de locomotion. La couche la plus basse dans la skip-liste peut-être interprétée comme un bus. Il s'arrête à chacun de ses arrêts prévus, son temps de parcours est très lent. La couche n\degree2, plus rapide, est un métro. La couche n\degree3, un train. Si un passager souhaite aller voir un concert à Bruxelles alors qu'il est à la gare de Charleroi, il ne va pas faire le trajet en bus. Il est tout naturel et plus rapide dans ce cas de prendre dans un premier temps le train, puis le métro afin qu'il se rapproche le plus près possible du concert. Si le dernier arrêt de métro n'a pas permis d'accéder à la salle du concert, seulement dans ce cas le passager doit emprunter le bus.
	
	\begin{figure}[h!]
		\includegraphics[width=\textwidth]{img/metaphore}
		\caption{Métaphore d'une skip-liste par un réseau de transport en commun}
		\label{skip-meta}
	\end{figure}
	
	\subsubsection*{Définition}
	La hauteur maximale d'une skip-list est définie lors de sa création. Bien qu'il n'y ait pas de taille maximale d'une skip-list, il est conseillé d'utiliser $log_2(n)$ où $n$ est le nombre d'éléments théoriques présents dans la liste.
	
	L'insertion dans la liste utilise une fonction basée sur la probabilité $p$ afin de définir sa hauteur maximale. Si $p$ vaut $\frac{1}{2}$, ça signifie que le nœud a une probabilité de $\frac{1}{2}$ d'être de hauteur 2, et a une probabilité $\frac{1}{4}$ d'être de hauteur 3. Un nœuds de hauteur $h$ possède $h$ pointeur. Un nœud de hauteur 3 a donc un accès au nœud suivant de hauteur 3, ainsi que celui de hauteur 2 et 1.
	
	En raison des probabilités, les nœuds supérieurs possèdent un pointeur vers un nœud plus avancé dans la liste. Une couche supérieure est donc une voie plus rapide. Ainsi, la couche la plus haute contient les plus grands sauts, et la couche la plus basse permet d'accéder à chacun des éléments.
		
	Le parcours d'une skip-list se fait de haut en bas, et de gauche à droite. Si la clé de l'élément suivant sur une couche est plus grande que celle qu'on recherche, celle-ci continue sur une voie inférieure.	
	
	\begin{figure}[h]
		\includegraphics[width=\textwidth]{img/struct}
		\caption{Structure d'une skip-list}
		\label{StructSkip}
	\end{figure}
	
	\subsection{La hauteur}
	La notion de hauteur est très importante dans une skip-liste. En effet, celle-ci permet de définir à combien de nœuds un élément est attaché. Si trop d'éléments possèdent la même hauteur, la recherche devient trop lente.	Cette méthode est définie à l'aide d'une fonction aléatoire. La hauteur ne dépend ni de la clé de l'élément ni de sa valeur. La fonction aléatoire doit être définie pour qu'un élément de hauteur $h$ possède le double de probabilités qu'un élément de hauteur $h+1$. Ainsi, si un nœud de hauteur 1 a une probabilité $p$ de $0.5$ alors le niveau 2 a une probabilité de $0.25$.
		
	\newpage
	\section{Les algorithmes}
	Une skip-list a besoin d'avoir un pointeur vers sa tête $(node* head)$. La liste doit connaitre le nombre de niveaux actuellement utilisés $(level)$. Selon les implémentations, il est possible de définir un nombre de couches maximal $(levelMAX)$. Il est aussi possible de changer le paramètre $(p)$ de probabilité de création d'une nouvelle couche. La variation de ces deux derniers paramètres est étudiée dans le chapitre \nameref{perf}.
	Un nœud contient une clé $key$ , une valeur $value$ ainsi qu'un tableau de pointeur vers les nœuds suivants $forward$. Il n'est pas nécessaire d'enregistrer la hauteur d'un nœud dans celui-ci.
	\lstinputlisting[linerange=BEGINSKStruct-ENDSKStruct]{SkipList/SkipList.h}
	
	L'initiation se fait de la manière suivante:
	\begin{itemize}
		\item La hauteur maximale est déterminée par le nombre d'éléments totaux $(n)$ présents dans la liste. Pour des questions de rapidité, la valeur $log_2(n)$ est recommandée.
		\item Création d'un élément $NIL$ possédant une clé plus grande que le maximum autorisé. Cette élément est aussi appelé \textit{élément bidon}.
		\item Définitions de ses pointeurs $forward$ vers lui-même.
		\item Le nombre de voies actuelles est fixé à 1.
		\item Le pointeur de tête est défini par cet élément $NIL$.
	\end{itemize}
	\emph{La création d'une skip-liste en langage C figure en annexe \ref{SKInit}.}
	
	\begin{figure}[h]
		\includegraphics{img/init}
		\caption{Initialisation d'une skip-liste}
		\label{SkipInit}
	\end{figure}
	
	\newpage
	\subsection{La recherche}
	De manière générale, pour rechercher dans une skip-list il suffit de commencer par le niveau le plus haut et d'effectuer une recherche élément par élément. Si l'élément suivant devient plus grand que celui recherché, il suffit alors de descendre d'un niveau dans la liste.
	
	Algorithmiquement parlant, La recherche d'un élément s'exécute de la façon suivante:
	\begin{enumerate}
		\item Commencer l'exploration de la liste par l'élément en tête, et se positionner sur la plus haute voie.
		\item Sur la voie actuelle, regarder la clé de l'élément suivant.
		\item Si elle est plus grande et qu'il existe une voie inférieure, descendre d'une voie.
		\item Sinon aller en 2.
		\item Si la clé de l'élément suivant correspond à celle qui est recherchée: l'élément a été trouvé.
		\item Sinon, l'élément n'a pas été trouvé.
	\end{enumerate}
	
	\emph{L'algorithme écrit en langage C figure en annexe \ref{SKSearch}.}
	
	\subsubsection*{Exemples}	
	\paragraph*{Comment rechercher l'élément 8 dans \cref{SkipSearch1}?}
	\begin{itemize}
		\item Se positionner sur la couche la plus haute: La 4ème voie.
		\item 8 est-il plus grand que 2 ? Oui, se positionner sur le nœud 2.
		\item 8 est-il plus grand que $+\infty$ \textit{(NIL)}? Non, descendre sur la 3ème voie.
		\item 8 est-il plus grand que 13  ? Non, descendre sur la 2ème voie.
		\item 8 est-il plus grand que 5 ? Oui, se positionner sur le nœud 5.
		\item 8 est-il plus grand que 13 ? Non, descendre sur la 1ère voie.
		\item 8 est-il plus grand que 8 ? Non, Il n'existe pas de voie plus basse.
		\item 5 est le dernier nœud parcouru. L'élément suivant sur la voie 1 est 8. 8 est-il l'élément recherché? Oui, la recherche est concluante.
	\end{itemize}
	\begin{figure}[h]
		\includegraphics[width=\textwidth]{img/search}
		\caption{Recherche de l'élément 8 dans une skip-liste}
		\label{SkipSearch1}
	\end{figure}
	
	\newpage
	\paragraph*{Comment rechercher l'élément 9 dans \cref{SkipSearch2}?}
	
	\begin{itemize}
		\item Se positionner sur la couche la plus haute: La 4ème voie.
		\item 8 est-il plus grand que 2 ? Oui, se positionner sur le nœud 2.
		\item 8 est-il plus grand que $+\infty$ \textit{(NIL)}? Non, descendre sur la 3ème voie.
		\item 8 est-il plus grand que 13  ? Non, descendre sur la 2ème voie.
		\item 8 est-il plus grand que 5 ? Oui, se positionner sur le nœud 5.
		\item 8 est-il plus grand que 13 ? Non, descendre sur la 1ère voie.
		\item 8 est-il plus grand que 8 ? Non, Il n'existe pas de voie plus basse.
		\item 5 est le dernier nœud parcouru. L'élément suivant sur la voie 1 est 9. 9 est-il l'élément recherché? Non, la recherche est infructueuse.
	\end{itemize}
	\begin{figure}[h]
		\includegraphics[width=\textwidth]{img/search2}
		\caption{Recherche de l'élément 9 dans une skip-liste}
		\label{SkipSearch2}
	\end{figure}
	
	
	\newpage
	\subsection{L'insertion}
	L'insertion d'une entrée dans une skip-list est essentiellement la même chose que la recherche. A l'exception qu'un tableau $update$, de taille identique à la hauteur de la liste, est utilisé pour mémoriser les pointeurs de chaque élément avant de descendre d'un niveau. Ce tableau est utilisé pour mettre à jour les liens nécessaires pour que la structure de donnée reste cohérente.
	
	Algorithmiquement parlant, l'insertion d'un élément dans une skip-liste s'effectue de la façon suivante:
	\begin{enumerate}
		\item Commencer l'exploration de la liste par l'élément en tête, et se positionner sur la plus haute voie.
		\item Sur la voie actuelle, regarder la clé de l'élément suivant.
		\item Si elle est plus grande et qu'il existe une voie inférieure, marquer ce pointeur. Puis, descendre d'une voie.
		\item Sinon aller en 2.
		\item Si la clé de l'élément suivant correspond à celle qui est recherchée: modifier la valeur de l'élément par celle de la valeur à insérer. \textbf{FIN}.
		\item Sinon, appeler la fonction de probabilité pour récupérer sa valeur $n$.
		\item Si $n$ est plus grand que la hauteur $h$ de la liste, mettre à jour les pointeurs supérieurs à $h$ vers $NIL$. Ensuite, définir la hauteur maximum actuelle $h$ à $n$.
		\item Créer le nœud $x$ de hauteur $n$.
		\item Pour chaque voie de $1$ à $n$.
		\item Mettre à jour les pointeurs de $x$ vers l'élément suivant de l'élément marqué de cette voie.
		\item Mettre à jour les pointeurs de l'élément marqué de cette voie vers $x$.
		\item \textbf{FIN}.
	\end{enumerate}
	\emph{L'algorithme écrit en langage C est présenté en annexe \ref{SKInsert}.}
	
	\newpage
	\subsubsection*{Exemples}	
	\paragraph*{Comment insérer l'élément 8 dans \cref{SkipInsert1}?}
	\begin{itemize}
		\item Se positionner sur la couche la plus haute: La 4ème voie.
		\item 8 est-il plus grand que 2 ? Oui, se positionner sur le nœud 2.
		\item 8 est-il plus grand que $+\infty$ \textit{(NIL)}? Enregistrer ce lien en mémoire, puis descendre sur la 3ème voie.
		\item 8 est-il plus grand que 13  ? Enregistrer ce lien en mémoire, puis descendre sur la 2ème voie.
		\item 8 est-il plus grand que 5 ? Oui, se positionner sur le nœud 5.
		\item 8 est-il plus grand que 13 ? Enregistrer ce lien en mémoire, puis descendre sur la 1ère voie.
		\item 8 est-il plus grand que 8 ? Enregistrer ce lien en mémoire, Il n'existe pas de voie plus basse.
		\item 5 est le dernier nœud parcouru. L'élément suivant sur la voie 1 est 8. 8 est-il l'élément recherché? Non, on crée un nouvel élément. Générer une hauteur aléatoire: hauteur 1.
		\item Ajouter un lien du nouvel élément 8 en voie 1. Ce lien doit pointer vers l'élément du lien enregistré à cette même voie. Il s'agit de l'élément 13.
		\item Modifier ce lien enregistré en voie 1 (de l'élément 5 vers l'élément 13) pour qu'il pointe vers ce nouvel élément 8.
		\item FIN.
	\end{itemize}
	\begin{figure}[h]
		\includegraphics[width=\textwidth]{img/insert}
		\caption{Insertion dans une skip-liste}
		\label{SkipInsert1}
	\end{figure}
	
	\newpage
	\paragraph*{Comment insérer l'élément 5 dans \cref{SkipInsert1}?}
	\begin{itemize}
		\item Se positionner sur la couche la plus haute: La 4ème voie.
		\item 5 est-il plus grand que 2 ? Oui, se positionner sur le nœud 2.
		\item 5 est-il plus grand que $+\infty$ \textit{(NIL)}? Enregistrer ce lien en mémoire, puis descendre sur la 3ème voie.
		\item 5 est-il plus grand que 13 ? Enregistrer ce lien en mémoire, puis descendre sur la 2ème voie.
		\item 5 est-il plus grand que 13 ? Enregistrer ce lien en mémoire, puis descendre sur la 1ère voie.
		\item 5 est-il plus grand que 3 ? Oui, se positionner sur le nœud 3.
		\item 5 est-il plus grand que 8 ? Enregistrer ce lien en mémoire, Il n'existe a pas de voie plus basse.
		\item 5 est le dernier nœud parcouru. L'élément suivant sur la voie 1 est 8. 8 est-il l'élément recherché? Non, on crée un nouvel élément. Générer une hauteur aléatoire: hauteur 2.
		\item Ajouter un lien du nouvel élément 5 en voie 1. Ce lien doit pointer vers l'élément du lien enregistré à cette même voie. Il s'agit de l'élément 8.
		\item Modifier ce lien enregistré en voie 1 (de l'élément 3 vers l'élément 8) pour qu'il pointe vers ce nouvel élément 5.
		\item Ajouter un lien du nouvel élément 5 en voie 2. Ce lien doit pointer vers l'élément du lien enregistré à cette même voie. Il s'agit de l'élément 13.
		\item Modifier ce lien enregistré en voie 2 (de l'élément 2 vers l'élément 13) pour qu'il pointe vers ce nouvel élément 5.
		\item FIN.
	\end{itemize}
	\begin{figure}[h]
		\includegraphics[width=\textwidth]{img/insert2}
		\caption{Insertion dans une skip-liste}
		\label{SkipInsert2}
	\end{figure}
	
	\newpage
	\subsection{La suppression}
	La suppression d'un élément dans une skip-liste s'effectue de la façon suivante:
	\begin{enumerate}
		\item Commencer l'exploration de la liste par l'élément en tête, et se positionner sur la plus haute voie.
		\item Sur la voie actuelle, regarder la clé de l'élément suivant.
		\item Si elle est plus grande et qu'il existe une voie inférieure, marquer ce nœud. Puis, descendre d'une voie.
		\item Sinon aller en 2.
		\item Si la clé de l'élément suivant ne correspond pas à celle qui est recherchée, \textbf{FIN}.
		\item Sinon pour chaque niveau de l'élément trouvé $x$, mettre à jour les pointeurs de l'élément marqué de cette voie vers l'élément suivant de $x$.
		\item Supprimer $x$.
		\item Si l'élément de tête de la hauteur actuelle de la liste pointe vers $NIL$, diminuer la hauteur actuelle de la liste de 1.
		\item Sinon, \textbf{FIN}.
		\item Si la hauteur est plus grande que 1, aller en 8.
	\end{enumerate}
	\emph{L'algorithme écrit en langage C figure en annexe \ref{SKDelete}.}
	\begin{center}
		\includegraphics[width=\textwidth]{img/delete}
	\end{center}
	
	\newpage
	\section{Analyse des performances}\label{perf}
	La caractéristique majeure de la skip-list est l'aléatoire. L'insertion d'un élément nouveau utilise une hauteur qui est déterminée par le hasard. De ce fait, une même séquence produira une liste différente. Cela a comme conséquence qu'aucune séquence prédéterminée de nombres ne peut produire une dégradation des performances, contrairement aux arbres binaires qui eux doivent être constamment rééquilibrés.
	
	De par sa nature probabiliste, on suppose que l'utilisateur n'aura pas un comportement à vouloir dégénérer volontairement la liste. C'est-à-dire que les performances peuvent être dégradées en retirant consciemment les éléments après avoir inspecté leur hauteur. Si l'utilisateur supprime tous les nœuds de hauteur $h>1$, le pire scénario de la skip-list équivaut à une liste chainée classique.
	
	Le temps requis pour exécuter l'insertion et la suppression dans une skip-list est prédominé par le temps de la recherche d'un élément. Ces deux derniers n'ont qu'un cout supplémentaire constant par rapport à la hauteur de la liste; alors que le cout de la recherche est proportionnel à la longueur du chemin à parcourir.
	
	
	\subsection{Analyse pour $p=\frac{1}{2}$}
	Pour une variable aléatoire $p=\frac{1}{2}$ et une skip-list de taille infinie, celle-ci tend à ce que chacun des niveaux possèdent $\frac{1}{2}$ moins d'éléments. Ainsi, le niveau 1 contient $n$ élément, le niveau 2 $\frac{n}{2}$, le niveau 3 $\frac{n}{4}$, ..., un élément à hauteur $h$: $\frac{n}{{2}^{h-1}}$. Par conséquent, le nombre total de liens dans une skip-list équivaut à \[n+\frac{n}{2}+\frac{n}{4}+\frac{n}{8}+\dots = \sum_{h=1}^{+\infty}\frac{n}{{2}^{h-1}}=2n\] Ce qui signifie qu'en moyenne un élément dans une skip-list possède 2 liens. Vu que la recherche se fait de haut en bas et de gauche à droite, chaque clé examinée à un niveau précis ($i$) ne peut pas appartenir à un niveau supérieur ($i+1$).
	De ce fait, on peut déduire qu'en moyenne le nombre de fois que l'on avance dans la liste à un niveau précis équivaut au nombre de liens divisé par le nombre d'éléments, soit $\frac{2n}{n}=2$.
	
	\newpage
	La probabilité qu'un élément soit de hauteur $i$ est de ${p^{i}} = \frac{1}{2^{i}} $. Le facteur $p$ est constant ($\frac{1}{2}$), la probabilité de la hauteur des clés est équiprobable. Si l'on additionne la probabilité de hauteur chacune des clés de la skip-list, et que l'on prend $h$ comme hauteur de la liste, on déduit la formule suivante.
	\[
		\frac{1}{{2}^{1}}+\frac{1}{{2}^{2}}+\frac{1}{{2}^{3}}+\dots+\frac{1}{{2}^{h}}
		= \sum _{i=1}^{h} ({\frac{1}{2}})^{i}
	\]
	Cette hauteur, il est possible de l'estimer. Si $h$ tend vers l'infini, la série converge vers 1. Ce qui a comme conséquence:
	\[
		n{(\frac{1}{2})}^{h} = 1
		\iff {(\frac{1}{2})}^{h}=\frac{1}{n}
		\iff h = \log_{\frac{1}{2}}(\frac{1}{n})
		\iff h = \log_{2}(n)
	\]
	
	L'algorithme de recherche effectue possède 2 boucles imbriquées. La boucle la plus profonde permet d'avancer de gauche à droite dans la liste. Pour $p=\frac{1}{2}$, en moyenne celle-ci avance de $2$. La boucle supérieure quant à elle varie selon la hauteur de la liste. La hauteur est estimée, avec une forte probabilité, à $\log_{2} n $. Si l'on combine les 2 estimations, nous avons donc une forte probabilité que la recherche s'effectue en $\log_{2}( 2n )$ opérations, soit $\mathcal{O}(log(n))$.
	
	
	\subsection{Généralisation}
	
	Le raisonnement utilisé précédemment pour $p=\frac{1}{2}$ reste valable quelle que soit la valeur de $p$, voir \cref{recap}. Le raisonnement qui effectue une sommation servant au calcul de lien dans une liste convergera vers $\frac{n}{p}$. Par contre, la somme des probabilités ($p^1 + p^2 + p^3 + ... + p^k$), converge toujours vers $\frac{p}{1-p}$. 
	 	
	 \begin{table}[h]
	 \begin{tabular}{|l|c|c|}
	 	\hline
	 	Scénario & attendu & pire \\
	 	\hline
	 	Nombre d'élément & $n$ & $n$ \\ 
	 	\hline
	 	Hauteur & $log_{\frac{1}{p}} n$ & $\infty$ \\ 
	 	\hline
	 	Nombre de lien & $n/p$ & $n*h$ \\ 
	 	\hline
	 	Recherche & $\mathcal{O}(\log n)$ & $\mathcal{O}(n)$ \\ 
	 	\hline
	 	Insertion & $\mathcal{O}(\log n)$ & $\mathcal{O}(n)$ \\
	 	\hline
	 	Suppression & $\mathcal{O}(\log n)$ & $\mathcal{O}(n)$\\
	 	\hline
	 \end{tabular}
	 \caption{Tableau récapitulatif}
	 \label{recap}
	 \end{table}
	 
	 \subsubsection*{Le pire cas}
	 	
	 Les ordinateurs ne possèdent pas une mémoire infinie. Par conséquent, il est impossible d'ajouter une infinité d'éléments. C'est pourquoi à la création d'une skip-list, la hauteur maximale est bornée par la formule du cas attendu avec une forte probabilité. Le pire scénario de hauteur infinie est donc impossible. Dans le cas très improbable que chacun des éléments de la skip-list soit à cette hauteur maximale, nous avons une recherche en $n*h$: soit $\mathcal{O}(n)$. 
	 	
	 De façon générale, avec une constance $c>1$ $h$ est plus grande que $c log n$ avec une probabilité d'au plus $\frac{1}{n^{c-1}}$. En d'autres mots, la probabilité que $h$ soit plus petit que $c log n$ est d'au moins $1-\frac{1}{n^{c-1}}$. Par conséquent, avec une forte probabilité, la hauteur d'une skip-liste est bien d'ordre $\mathcal{O}(log n)$. Par exemple: si $n=1000$, la probabilité est d'une sur un million.
	
	
	\subsection{Expérimentation}
	
	Les expérimentations suivantes ont été réalisées sur un ordinateur Windows 10 64 bits possédant un AMD FX 8350 et 16Gb de RAM. Les tests ont été lancés $10^5$ fois, les résultats présentés sont la moyenne de tous les tests. Les très légères différences avec les résultats attendu peuvent s'expliquer par la façon dont un ordinateur génère des nombres aléatoires. On parle d'ailleurs de nombre "pseudo" aléatoire.
	
	L'algorithme utilisé pour générer les nombres aléatoires dans ces tests est \textit{xoroshiro128+}. Il a été développé par David Blackman et Sebastiano Vigna. Il s'agit de l'algorithme le plus rapide aujourd'hui. Il est intéressant d'utiliser un générateur rapide afin de déterminer la hauteur d'un élément de la skip-list. L'utilisation de la fonction \textit{rand} de \textit{stdlib} permet d'insérer $10^7$ éléments en $5.792$ secondes, alors que l'algorithme \textit{xoroshiro128+} permet d'en insérer autant en $4.014$ secondes. Cette différence de $30\%$ n'est pas négligeable.
	
	\begin{table}[h]
		\resizebox{\columnwidth}{!}{
			\begin{tabular}{|c|r|r|r|r|r|r|r|r|r|r|}
				\hline
				\backslashbox{p}{h} & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
				\hline
				4/5 & 1000.00 & 800.05 & 640.02 & 512.01 & 409.64 & 327.74 & 262.16 & 209.74 & 167.81 & 134.23 \\
				3/4 & 1000.00 & 749.97 & 562.52 & 421.83 & 316.34 & 237.25 & 177.98 & 133.45 & 100.10 & 75.07 \\
				2/3 & 1000.00 & 666.76 & 444.52 & 296.35 & 197.60 & 131.70 & 87.79 & 58.49 & 38.98 & 25.99  \\
				3/5 & 1000.00 & 600.00 & 360.00 & 216.02 & 129.61 & 77.77 & 46.66 & 28.00 & 16.79 & 10.06 \\
				1/2 & 1000.00 & 500.01 & 250.06 & 125.04 & 62.56 & 31.27 & 15.63 & 7.82 & 3.91 & 1.96 \\
				2/5 & 1000.00 & 399.96 & 160.02 & 64.01 & 25.60 & 10.23 & 4.09 & 1.63 & 0.00 & 0.00 \\
				1/3 & 1000.00 & 333.33 & 111.14 & 37.03 & 12.34 & 4.11 & 0.00 & 0.00 & 0.00 & 0.00 \\
				1/4 & 1000.00 & 249.97 & 62.48 & 15.63 & 3.90 & 0.00 & 0.00 & 0.00 & 0.00 & 0.00 \\
				1/5 & 1000.00 & 200.04 & 40.00 & 8.01 & 0.00 & 0.00 & 0.00 & 0.00 & 0.00 & 0.00 \\
				1/10 & 1000.00 & 100.01 & 10.02 & 0.00 & 0.00 & 0.00 & 0.00 & 0.00 & 0.00 & 0.00 \\
				1/20 & 1000.00 & 50.00 & 0.00 & 0.00 & 0.00 & 0.00 & 0.00 & 0.00 & 0.00 & 0.00 \\
				\hline
			\end{tabular}
		}
		\caption{Le nombre d'éléments par niveau en fonction de $p$}
		\label{tbRes1}
	\end{table}
	
	\subsubsection*{Variation de p}

	Afin de vérifier que le $p$ à bien l'effet voulu, il suffit de compter le nombre d'éléments existants à chaque niveau. S'il y a $n$ éléments à la hauteur 1, on s'attend à obtenir $np$ éléments de hauteur 2 avec une forte probabilité.
	
	Dans les faits, en essayant différentes valeurs pour une skip-list de 1000 éléments, on  peut obtenir les résultats présents dans la \cref{tbRes1}. Le résultat obtenu, correspond à notre espérance: $p$ influence correctement la hauteur de la liste et par conséquent son poids. 
	
	Une question plus intéressante à se poser serait: Quel est la meilleure valeur pour $p$ ? Choisir un petit nombre réduit le nombre de liens dans la liste. Cela a comme conséquence de pouvoir faire de plus grand saut, mais moins souvent. Par exemple avec $p=0.1$, il sera fort probable de faire des sauts d'une dizaine d'éléments. Mais la recherche du 9ème élément se fera sur la couche la plus basse qui elle, est 10 fois lente. En revanche, choisir un grand nombre pour $p$, augmentera fortement le nombre de liens dans la skip-list. Celle-ci possède donc un grand nombre de hauteurs, et donc plus de saut. Cela a comme conséquence de faire plus souvent des sauts, mais ils seront plus petits.
	 
	\begin{figure}[h]
		\centering
		\resizebox{0.8\columnwidth}{!}{
			\begin{tikzpicture}
			\begin{axis}[
				ymin=300,xmin=0.05,xmax=0.80,xtick distance=0.1,ytick distance=100,
				ylabel={Temps},
				xlabel=Valeur de $p$
			]
			\addplot+[smooth,mark min] table [x=p,y=1000] {data/pvar.dat};
			\addplot+[smooth,mark min] table [x=p,y=10000] {data/pvar.dat};
			\addplot+[smooth,mark min] table [x=p,y=100000] {data/pvar.dat};
			\addplot+[smooth,mark min] table [x=p,y=1000000] {data/pvar.dat};		
			\end{axis}
			\end{tikzpicture}
		}
		\caption{Vitesse d'exécution en fonction de $p$}
		\label{tbRes2}
	\end{figure}
	
	\section{Comparaisons avec d'autres structures}
	Dans la conception logiciel, choisir la bonne structure de donnée permet aux logiciels de s'exécuter plus rapidement. Laquelle présentera les meilleurs performances? Quels sont les avantages et le prix à payer? Pour l'ensemble de ces tests, un logiciel de comparaisons doit être utilisé spécialement développé pour ce projet.
	Il existe un grand nombre de méthode différente pour enregistrer des données au format "clé-valeur". Ces structures de donnée sont appelés des dictionnaires. Dans un dictionnaire de langue française, chacun des mots est associé à une définition. Ces mots sont triés par ordre alphabétique afin d'effectuer des recherches rapides. En informatique, c'est le même concept qui est utilisé: Chacune des clés (mots) correspond une valeur (définitions). Les clés, quand à elle, seront structurée de façon organisée afin de pouvoir les trouver rapidement.
	
	\subsection{La table de hachage}
	La table de hachage une structure de donnée qui fonctionne grâce à des listes chainées. Le pointeur du premier élément est placé dans un vecteur. Ce vecteur est typiquement initialisé pour contenir 128 éléments. 
	
	Lors de l'insertion dans cette table, la clé est transformé à l'aide d'une méthode de "hachage". Cette dernière doit être capable de répartir efficacement les éléments tout en étant déterministe. C'est à dire, qu'insérer ou rechercher un élément ayant comme clé "4000" doit toujours atteindre la même case du vecteur. 
	
	Si 2 éléments doivent s'insérer dans la même case du vecteur, ceux-ci sont alors placé dans une liste chainée. Par exemple, si la clé "48" et la clé "24" ont comme résultat la case 12 par la fonction de hachage. L'élément 24 sera le premier élément de la liste chainée, suivit de 48.
	
	Lorsque trop d'élément sont présent dans une même case, la table de hachage doit pouvoir agrandir la taille de son vecteur. Cette modification, impose que chacun des éléments présent dans la table soit déplacé pour correspondre aux nouveaux indices calculés par la fonction de hachage. Le nombre maximum de collision autorisée par case est typiquement 4, mais peut-être configuré autrement. Une table de hachage de 128 case, peut dont contenir 512 éléments. 
	
	\lstinputlisting[linerange=BEGINStruct-ENDStruct]{SkipList/HashTable.h}
	\lstinputlisting[linerange=BEGINStruct-ENDStruct]{SkipList/LinkList.h}
	
	\subsubsection*{Avantages}
	\begin{itemize}
		\item Rapidité d'insertion et de recherche
		\item Mises en place simple
	\end{itemize}
	\subsubsection*{Inconvénient}
	\begin{itemize}
		\item La fonction de hachage doit être suffisamment efficace pour éviter les collisions.
		\item Réallocation et déplacement des éléments en cas de grand nombre de collisions.
		\item L'utilisation d'un vecteur pour la table, limite le nombre maximum d'élément.
	\end{itemize}
	\subsubsection*{Performances}
	Afin de négliger la méthode de hachage pour ce test: les clés sont des entiers et la méthode de hachage est la clé modulo la taille de la table. Ainsi, il est possible d'utiliser l'intégralité de la table en minimisant les collisions. Il suffit alors d'insérer des clés de façon séquentielles (0, 1, 2, 3...).
	
	 \begin{table}[h]
	 	\begin{tabular}{|l|c|c|}
	 		\hline
	 		Scénario & attendu & pire \\
	 		\hline
	 		Recherche & $\mathcal{O}(1)$ & $\mathcal{O}(n)$ \\ 
	 		\hline
	 		Insertion & $\mathcal{O}(1)$ & $\mathcal{O}(2n)$ \\
	 		\hline
	 		Suppression & $\mathcal{O}(1)$ & $\mathcal{O}(n)$\\
	 		\hline
	 	\end{tabular}
	 	\caption{Tableau récapitulatif}
	 \end{table}
	
	\begin{figure}[h]
		\centering
		\resizebox{\columnwidth}{!}{
			\begin{tikzpicture}
			\begin{axis} [
				axis y line*=left,
				ymin=0,ymax=5270,xmin=0,xmax=1048576,
				ylabel=Temps en ms,
				ylabel near ticks,
				scaled x ticks={base 10:-3},
				scaled y ticks={base 10:-3},
				xlabel=Le nombre d élément,
				legend pos=north west,
			]
			\addplot+[smooth, mark=none] table [x=elem,y=time] {data/hashtable.dat};
				
			\end{axis}
			
			\end{tikzpicture}
		}
		\caption{Vitesse d'exécution de la table de hachage}
	\end{figure}
	
	\newpage
	\subsection{Les arbres binaires}
	Un arbres binaires de recherche est une structure de donnée dans laquelle chacun des éléments possèdent 2 sous éléments. On parle alors de "fils gauche" et de "fils droit". Ces derniers peuvent eux-aussi à leur tour, posséder un fils gauche et droit. On parle dès lors, de structures récursive.
	
	\lstinputlisting[linerange=BEGINStruct-ENDStruct]{SkipList/Tree.h}
	
	Chacun des nœuds a donc 2 fils: le gauche contient un élément plus petit que son parent; le fils droit qui contient un élément plus grand que son parent. Par exemple, un nœud de valeur 5 aura comme fils de gauche 3, et comme fils droit 13.
	
	Les recherches dans un arbre s'effectuent depuis la racine de l'arbre, soit le nœud le plus haut dans sa hiérarchie. Il faut ensuite comparer l'élément courant avec celui qui est recherché. S'il est plus grand, il faut descendre sur le fils droit, sinon sur le fils gauche. La recherche continue en comparant avec ce dernier élément sélectionné. L'exploration de l'arbre s'arrête lorsque l'élément est trouvé, ou qu'un nœud n'a plus de fils.
	
	Les insertions et suppressions dans un arbre dépendent de la recherche. Il faut en effet garder la structure cohérente. Si un élément parent est supprimé, il faut être capable de le remplacer par un autre sans détériorer l'arbre.
	
	Les insertions séquentielles posent problème dans un arbre. En effet, dans une suite de nombres strictement croissants, chacun des nombres est par définition plus grand que son précédent. Par conséquent, de telles insertions dans un arbre provoqueront une dégradation significative des performances. Le nombre inséré étant plus grand que son précédent, celui-ci est toujours ajouté sur le fils droit. Le fils de gauche n'est par conséquent jamais utilisé; ce qui transforme l'arbre en liste chainée ordonnée.
	
	 \begin{table}[h]
	 	\begin{tabular}{|l|c|c|}
	 		\hline
	 		Scénario & attendu & pire \\
	 		\hline
	 		Recherche & $\mathcal{O}(\log n)$ & $\mathcal{O}(n)$ \\ 
	 		\hline
	 		Insertion & $\mathcal{O}(\log n)$ & $\mathcal{O}(n)$ \\
	 		\hline
	 		Suppression & $\mathcal{O}(\log n)$ & $\mathcal{O}(n)$\\
	 		\hline
	 	\end{tabular}
	 	\caption{Tableau récapitulatif}
	 \end{table}
	
	\subsubsection*{Avantages}
	\begin{itemize}
		\item Rapidité d'exécution, si l'arbre est équilibré
		\item Mises en place simple et rapide.
	\end{itemize}
	\subsubsection*{Inconvénient}
	\begin{itemize}
		\item L'insertion provoque rapidement un déséquilibre, ce qui détériore très fortement les performances
	\end{itemize}
	\subsubsection*{Performances}
	\begin{figure}[h]
		\centering
		\resizebox{\columnwidth}{!}{
			\begin{tikzpicture}
			\begin{axis} [
			axis y line*=left,
			ymin=0,ymax=5270,xmin=0,xmax=65536,
			ylabel=Temps en ms,
			ylabel near ticks,
			scaled x ticks={base 10:-3},
			scaled y ticks={base 10:-3},
			xlabel=Le nombre d élément,
			legend pos=north east,
			]
			\addplot+[mark=none, blue] table [x=elem,y=sequence] {data/tree.dat};
			\addplot+[mark=none, green] table [x=elem,y=random] {data/tree.dat};
			
			\addlegendentry{séquence}
			\addlegendentry{random}
			
			
			\end{axis}
			
			\end{tikzpicture}
		}
		\caption{Vitesse d'exécution d'un arbre binaire}
	\end{figure}
	\begin{table}[h]
		\begin{tabular}{|l|c|c|}
			\hline
			Scénario & attendu & pire \\
			\hline
			Recherche & $\mathcal{O}(\log n)$ & $\mathcal{O}(n)$ \\ 
			\hline
			Insertion & $\mathcal{O}(\log n)$ & $\mathcal{O}(n)$ \\
			\hline
			Suppression & $\mathcal{O}(\log n)$ & $\mathcal{O}(n)$\\
			\hline
		\end{tabular}
		\caption{Tableau récapitulatif}
	\end{table}
	
	\subsection{Les arbres rouge noire}
	Les arbres rouges noires sont une amélioration des arbres binaires. Un nœud possède un attribue supplémentaire, sa couleur qui peut être soit rouge, soit noir. Ceci permet d'ajouter des contraintes dans l'arbre. Ces contraintes permettent à ré-équilibrer l'arbre par des rotations. Il faut transformer l'arbre afin que le parent d'un nœud rouge est noir. Mais aussi pour que le chemin de chaque feuille à la racine contient le même nombre de nœud noir.
	
	Lors de l'insertion un nœud est rouge, mais en raison des transformation appliquée afin de garantir l'intégrité de la structure, il est possible qu'un nœud inséré ne soit pas une feuille, mais un parent. Il peut donc devenir à son tour noir. La recherche s'effectue exactement de la même façon qu'un arbre binaire. 
	\subsubsection*{Avantages}
	\begin{itemize}
		\item Rapidité d'exécution
		\item L'arbre est toujours équilibré
	\end{itemize}
	\subsubsection*{Inconvénient}
	\begin{itemize}
		\item Algorithme complexe à mettre en place en raison de nombreuses études de cas.
		\item Certaines séquences de nombre provoqueront un rééquilibrage systématique.
	\end{itemize}
	\subsubsection*{Performances}
	\begin{figure}[h]
		\centering
		\resizebox{\columnwidth}{!}{
			\begin{tikzpicture}
			\begin{axis} [
			axis y line*=left,
			ymin=0,ymax=10000,xmin=0,xmax=2000000,
			ylabel=Temps en ms,
			ylabel near ticks,
			scaled x ticks={base 10:-3},
			scaled y ticks={base 10:-3},
			xlabel=Le nombre d élément,
			legend pos=north east,
			]
			\addplot+[mark=none, blue] table [x=elem,y=sequence] {data/rbtree.dat};
			\addplot+[mark=none, green] table [x=elem,y=random] {data/rbtree.dat};
			
			\addlegendentry{séquence}
			\addlegendentry{random}
			
			\end{axis}
			
			\end{tikzpicture}
		}
		\caption{Vitesse d'exécution d'un arbre rouge noir}
	\end{figure}
	\begin{table}[h]
		\begin{tabular}{|l|c|c|}
			\hline
			Scénario & attendu & pire \\
			\hline
			Recherche & $\mathcal{O}(\log n)$ & $\mathcal{O}(\log n)$ \\ 
			\hline
			Insertion & $\mathcal{O}(\log n)$ & $\mathcal{O}(\log n)$ \\
			\hline
			Suppression & $\mathcal{O}(\log n)$ & $\mathcal{O}(\log n)$\\
			\hline
		\end{tabular}
		\caption{Tableau récapitulatif}
	\end{table}
	
	\subsection{La Skip-List}
	\subsubsection*{Avantages}
	\begin{itemize}
		\item Rapidité d'exécution
		\item Algorithme simple
	\end{itemize}
	\subsubsection*{Inconvénient}
	\begin{itemize}
		\item Non déterministe
	\end{itemize}
	\subsubsection*{Performances}
	\begin{figure}[h]
		\centering
		\resizebox{\columnwidth}{!}{
			\begin{tikzpicture}
			\begin{axis} [
			axis y line*=left,
			ymin=0,ymax=10000,xmin=0,xmax=2000000,
			ylabel=Temps en ms,
			ylabel near ticks,
			scaled x ticks={base 10:-3},
			scaled y ticks={base 10:-3},
			xlabel=Le nombre d élément,
			legend pos=north east,
			]
			\addplot+[mark=none, blue] table [x=elem,y=sequence] {data/skiplist.dat};
			\addplot+[mark=none, green] table [x=elem,y=random] {data/skiplist.dat};
			
			\addlegendentry{séquence}
			\addlegendentry{random}
			
			\end{axis}
			
			\end{tikzpicture}
		}
		\caption{Vitesse d'exécution d'une skip-list}
	\end{figure}
	
	\newpage
	c
	\newpage
	d
	\newpage
	
	\begin{appendices}
	\section{Représentation d'une Skip-List en langage C}
	\subsection{Initiation}\label{SKInit}
	\lstinputlisting[linerange=BEGINSKInit-ENDSKInit]{SkipList/SkipList.c}
	\subsection{Fonction aléatoire}\label{SKRandom}
	\lstinputlisting[linerange=BEGINSKRandom-ENDSKRandom]{SkipList/SkipList.c}

	\subsection{Recherche}\label{SKSearch}
	\lstinputlisting[linerange=BEGINSKSearch-ENDSKSearch]{SkipList/SkipList.c}

	\subsection{Insertion}\label{SKInsert}
	\lstinputlisting[linerange=BEGINSKInsert-ENDSKInsert]{SkipList/SkipList.c}
	
	\subsection{Suppression}\label{SKDelete}
	\lstinputlisting[linerange=BEGINSKDelete-ENDSKDelete]{SkipList/SkipList.c}
	\newpage
	\end{appendices}
	
	
	@online{1,
		author = {Patrice Roy},
		title = {Skip Lists},
		date = {27/02/2016},
		url = {http://h-deb.clg.qc.ca/Sujets/Structures-donnees/SkipLists.html},
	}
	@online{2,
		author = {Sylvie Hamel},
		title = {Dictionnaires ordonnés et “Skip List”},
		date = {25/02/2016},
		url = {http://www.iro.umontreal.ca/~hamelsyl/SkipList.pdf},
	}
	
	https://openclassrooms.com/courses/c-bien-choisir-ses-structures-de-donnees
	
\end{document} 